import "pkg:/source/promises.bs"

namespace tests
	@SGNode("test")
	@suite
	class PromisesTests extends rooibos.BaseTestSuite

		'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		@describe("promises.create()")
		'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

		@it("create promise")
		sub _()
			promise = promises.create()
			m.assertTrue(promises.isPromise(promise))
		end sub

		'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		@describe("promises.isPromise()")
		'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

		@it("promise validation")
		sub _()
			m.assertTrue(promises.isPromise(promises.create()))
			promiseNode = createNode("node", { promiseState: 0 })
			m.assertTrue(promises.isPromise(promiseNode))
			notPromise = createNode()
			m.assertFalse(promises.isPromise(notPromise))
			m.assertFalse(promises.isPromise(invalid))
		end sub

		'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		@describe("promises.isComplete()")
		'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

		@it("promise settlement check")
		sub _()
			m.assertFalse(promises.isComplete(promises.create()))
			m.assertTrue(promises.isComplete(promises.resolve({})))
			m.assertTrue(promises.isComplete(promises.reject({})))
			m.assertFalse(promises.isComplete(createNode()))
			m.assertFalse(promises.isComplete(invalid))
		end sub

		'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		@describe("promises.chain()")
		'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

		@it("promise chain follows happy path")
		function _()
			context = {
				thenCount: 0
				catchCount: 0
				finallyCount: 0
				result: ""
			}

			results = promises.chain(promises.resolve(1), context).then(sub(result, context)
				context.thenCount++
				context.result = result
			end sub).catch(sub(error, context)
				context.catchCount++
			end sub).finally(sub(context)
				context.finallyCount++
			end sub).toPromise()

			return promises.onFinally(results, sub(context)
				m.testSuite.assertEqual(context, {
					thenCount: 1
					catchCount: 0
					finallyCount: 1
					result: 1
				})
			end sub, context)
		end function

		@it("handles default then identify passthrough calls")
		function _()
			context = {
				thenCount: 0
				catchCount: 0
				finallyCount: 0
				result: []
			}

			results = promises.chain(promises.resolve(1), context).then(function(result, context)
				context.thenCount++
				context.result.push(result)
				return 2
			end function).then().then().then(function(result, context)
				context.thenCount++
				context.result.push(result)
			end function).catch(sub(error, context)
				context.catchCount++
			end sub).finally(sub(context)
				context.finallyCount++
			end sub).toPromise()

			return promises.onFinally(results, sub(context)
				m.testSuite.assertEqual(context, {
					thenCount: 2
					catchCount: 0
					finallyCount: 1
					result: [1, 2]
				})
			end sub, context)
		end function

		@it("calls thens in order")
		function _()
			context = {
				thenCount: 0
				catchCount: 0
				finallyCount: 0
				result: []
			}

			results = promises.chain(promises.resolve(1), context).then(function(result, context)
				context.thenCount++
				context.result.push(result)
				return 2
			end function).then(function(result, context)
				context.thenCount++
				context.result.push(result)
				return 3
			end function).then(function(result, context)
				context.thenCount++
				context.result.push(result)
				return 4
			end function).then(function(result, context)
				context.thenCount++
				context.result.push(result)
			end function).catch(sub(error, context)
				context.catchCount++
			end sub).finally(sub(context)
				context.finallyCount++
			end sub).toPromise()

			return promises.onFinally(results, sub(context)
				m.testSuite.assertEqual(context, {
					thenCount: 4
					catchCount: 0
					finallyCount: 1
					result: [1, 2, 3, 4]
				})
			end sub, context)
		end function

		@it("calls catches in order")
		function _()
			context = {
				thenCount: 0
				catchCount: 0
				finallyCount: 0
				result: []
			}

			results = promises.chain(promises.reject(1), context).then(function(result, context)
				context.thenCount++
				context.result.push(invalid)
			end function).catch(function(result, context)
				context.catchCount++
				context.result.push(result)
				return promises.reject(2)
			end function).catch(function(result, context)
				context.catchCount++
				context.result.push(result)
				return promises.reject(3)
			end function).catch(function(result, context)
				context.catchCount++
				context.result.push(result)
				return promises.reject(4)
			end function).catch(function(result, context)
				context.catchCount++
				context.result.push(result)
			end function).finally(sub(context)
				context.finallyCount++
			end sub).toPromise()

			return promises.onFinally(results, sub(context)
				m.testSuite.assertEqual(context, {
					thenCount: 0
					catchCount: 4
					finallyCount: 1
					result: [1, 2, 3, 4]
				})
			end sub, context)
		end function

		@it("handles default then thrower passthrough calls")
		function _()
			context = {
				thenCount: 0
				catchCount: 0
				finallyCount: 0
				result: []
			}

			results = promises.chain(promises.reject(1), context).then(function(result, context)
				context.thenCount++
				context.result.push(invalid)
			end function).catch(function(result, context)
				context.catchCount++
				context.result.push(result)
				return promises.reject(2)
			end function).catch().catch().catch(function(result, context)
				context.catchCount++
				context.result.push(result)
			end function).finally(sub(context)
				context.finallyCount++
			end sub).toPromise()

			return promises.onFinally(results, sub(context)
				m.testSuite.assertEqual(context, {
					thenCount: 0
					catchCount: 2
					finallyCount: 1
					result: [1, 2]
				})
			end sub, context)
		end function

		@it("calls finally in order")
		function _()
			context = {
				thenCount: 0
				catchCount: 0
				finallyCount: 0
				result: []
			}

			results = promises.chain(promises.resolve(1), context).then(function(result, context)
				context.thenCount++
				context.result.push(result)
				return 2
			end function).then(function(result, context)
				context.thenCount++
				context.result.push(result)
				return 3
			end function).then(function(result, context)
				context.thenCount++
				context.result.push(result)
				return 4
			end function).then(function(result, context)
				context.thenCount++
				context.result.push(result)
			end function).catch(sub(error, context)
				context.catchCount++
			end sub).finally(function(context)
				context.finallyCount++
			end function).finally(function(context)
				context.finallyCount++
			end function).finally(function(context)
				context.finallyCount++
			end function).finally(function(context)
				context.finallyCount++
			end function).toPromise()

			return promises.onFinally(results, sub(context)
				m.testSuite.assertEqual(context, {
					thenCount: 4
					catchCount: 0
					finallyCount: 4
					result: [1, 2, 3, 4]
				})
			end sub, context)
		end function

		@it("handles default finally passthrough calls")
		function _()
			context = {
				thenCount: 0
				catchCount: 0
				finallyCount: 0
				result: []
			}

			results = promises.chain(promises.resolve(1), context).then(function(result, context)
				context.thenCount++
				context.result.push(result)
				return 2
			end function).then(function(result, context)
				context.thenCount++
				context.result.push(result)
				return 3
			end function).then(function(result, context)
				context.thenCount++
				context.result.push(result)
				return 4
			end function).then(function(result, context)
				context.thenCount++
				context.result.push(result)
			end function).catch(sub(error, context)
				context.catchCount++
			end sub).finally(function(context)
				context.finallyCount++
			end function).finally().finally().finally(function(context)
				context.finallyCount++
			end function).toPromise()

			return promises.onFinally(results, sub(context)
				m.testSuite.assertEqual(context, {
					thenCount: 4
					catchCount: 0
					finallyCount: 2
					result: [1, 2, 3, 4]
				})
			end sub, context)
		end function

		@it("skips thens when promise is rejected")
		function _()
			context = {
				thenCount: 0
				catchCount: 0
				finallyCount: 0
				result: []
				error: ""
			}

			results = promises.chain(promises.resolve(1), context).then(function(result, context)
				context.thenCount++
				context.result.push(result)
				return promises.reject("rejected")
			end function).then(function(result, context)
				context.thenCount++
				context.result.push(invalid)
			end function).then(function(result, context)
				context.thenCount++
				context.result.push(invalid)
			end function).then(function(result, context)
				context.thenCount++
				context.result.push(invalid)
			end function).catch(sub(error, context)
				context.catchCount++
				context.error = error
			end sub).finally(sub(context)
				context.finallyCount++
			end sub).toPromise()

			return promises.onFinally(results, sub(context)
				m.testSuite.assertEqual(context, {
					thenCount: 1
					catchCount: 1
					finallyCount: 1
					result: [1]
					error: "rejected"
				})
			end sub, context)
		end function

		@it("ignores return value from finally when not crash or rejected promise")
		function _()
			context = {
				thenCount: 0
				catchCount: 0
				finallyCount: 0
				result: ""
			}

			results = promises.chain(promises.resolve("I am happy"), context).finally(function(context)
				context.finallyCount++
				return "I am sad"
			end function).then(sub(result as dynamic, context as dynamic)
				context.thenCount++
				context.result = result
			end sub).catch(sub(result as dynamic, context as dynamic)
				context.catchCount++
			end sub).toPromise()

			return promises.onFinally(results, sub(context)
				m.testSuite.assertEqual(context, {
					thenCount: 1
					catchCount: 0
					finallyCount: 1
					result: "I am happy"
				})
			end sub, context)
		end function

		@it("finally does not prevent rejection from propagating down the chain")
		function _()
			context = {
				thenCount: 0
				catchCount: 0
				finallyCount: 0
				errorMessage: ""
			}

			results = promises.chain(promises.reject("Crash"), context).finally(sub(context)
				context.finallyCount++
			end sub).then(sub(result as dynamic, context as dynamic)
				context.thenCount++
			end sub).catch(sub(result as dynamic, context as dynamic)
				context.catchCount++
				context.errorMessage = result
			end sub).toPromise()

			return promises.onFinally(results, sub(context)
				m.testSuite.assertEqual(context, {
					thenCount: 0
					catchCount: 1
					finallyCount: 1
					errorMessage: "Crash"
				})
			end sub, context)
		end function

		@it("finally that returns resolved promises does not prevent rejection from propagating down the chain")
		function _()
			context = {
				thenCount: 0
				catchCount: 0
				finallyCount: 0
				errorMessage: ""
			}

			results = promises.chain(promises.reject("Crash"), context).finally(function(context)
				context.finallyCount++
				return promises.resolve(true)
			end function).then(sub(result as dynamic, context as dynamic)
				context.thenCount++
			end sub).catch(sub(result as dynamic, context as dynamic)
				context.catchCount++
				context.errorMessage = result
			end sub).toPromise()

			return promises.onFinally(results, sub(context)
				m.testSuite.assertEqual(context, {
					thenCount: 0
					catchCount: 1
					finallyCount: 1
					errorMessage: "Crash"
				})
			end sub, context)
		end function

		@it("finally that returns value does not prevent rejection from propagating down the chain")
		function _()
			context = {
				thenCount: 0
				catchCount: 0
				finallyCount: 0
				errorMessage: ""
			}

			results = promises.chain(promises.reject("Crash"), context).finally(function(context)
				context.finallyCount++
				return true
			end function).then(sub(result as dynamic, context as dynamic)
				context.thenCount++
			end sub).catch(sub(result as dynamic, context as dynamic)
				context.catchCount++
				context.errorMessage = result
			end sub).toPromise()

			return promises.onFinally(results, sub(context)
				m.testSuite.assertEqual(context, {
					thenCount: 0
					catchCount: 1
					finallyCount: 1
					errorMessage: "Crash"
				})
			end sub, context)
		end function

		@it("returned rejection in finally is propagated down the chain")
		function _()
			context = {
				thenCount: 0
				catchCount: 0
				finallyCount: 0
				errorMessage: ""
			}

			results = promises.chain(promises.reject("Crash"), context).finally(function(context)
				context.finallyCount++
				return promises.reject("error in finally")
			end function).then(sub(result as dynamic, context as dynamic)
				context.thenCount++
			end sub).catch(sub(result as dynamic, context as dynamic)
				context.catchCount++
				context.errorMessage = result
			end sub).toPromise()

			return promises.onFinally(results, sub(context)
				m.testSuite.assertEqual(context, {
					thenCount: 0
					catchCount: 1
					finallyCount: 1
					errorMessage: "error in finally"
				})
			end sub, context)
		end function

		@it("crash in finally is propagated down the chain")
		function _()
			context = {
				thenCount: 0
				catchCount: 0
				finallyCount: 0
				errorMessage: ""
			}

			results = promises.chain(promises.reject("Crash"), context).finally(function(context)
				context.finallyCount++
				throw "error in finally"
			end function).then(sub(result as dynamic, context as dynamic)
				context.thenCount++
			end sub).catch(sub(result as dynamic, context as dynamic)
				context.catchCount++
				context.errorMessage = result.message
			end sub).toPromise()

			return promises.onFinally(results, sub(context)
				m.testSuite.assertEqual(context, {
					thenCount: 0
					catchCount: 1
					finallyCount: 1
					errorMessage: "error in finally"
				})
			end sub, context)
		end function

		'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		@describe("promises.all()")
		'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

		@it("handled non-array")
		function _()
			context = {
				thenCount: 0
				catchCount: 0
				errorMessage: ""
				backtrace: invalid
			}

			results = promises.chain(promises.all(invalid), context).then(sub(result, context)
				context.thenCount++
			end sub).catch(function(error, context)
				context.catchCount++
				context.errorMessage = error.message
				context.backtrace = error.backtrace
				return true
			end function).toPromise()

			return promises.onFinally(results, sub(context)
				backtrace = context.backtrace
				context.delete("backtrace")
				m.testSuite.assertEqual(context, {
					thenCount: 0
					catchCount: 1
					errorMessage: "Did not supply an array"
				})
				m.testSuite.assertNotInvalid(backtrace)
			end sub, context)
		end function

		@it("handled empty array")
		function _()
			context = {
				thenCount: 0
				catchCount: 0
				result: invalid
			}

			results = promises.chain(promises.all([]), context).then(sub(result, context)
				context.thenCount++
				context.result = result
			end sub).catch(sub(_, context)
				context.catchCount++
			end sub).toPromise()

			return promises.onFinally(results, sub(context)
				m.testSuite.assertEqual(context, {
					thenCount: 1
					catchCount: 0
					result: []
				})
			end sub, context)
		end function

		@it("resolving all promises")
		function _()
			context = {
				thenCount: 0
				catchCount: 0
				result: invalid
			}

			results = promises.chain(promises.all([
				promises.resolve(1)
				promises.resolve(2)
				promises.resolve(3)
			]), context).then(sub(result, context)
				context.thenCount++
				context.result = result
			end sub).catch(sub(_, context)
				context.catchCount++
			end sub).toPromise()

			return promises.onFinally(results, sub(context)
				m.testSuite.assertEqual(context, {
					thenCount: 1
					catchCount: 0
					result: [1, 2, 3]
				})
			end sub, context)
		end function

		@it("resolving works with non-promise entire all promises")
		function _()
			context = {
				thenCount: 0
				catchCount: 0
				result: invalid
			}

			results = promises.chain(promises.all([
				promises.resolve(1)
				2
				promises.resolve(3)
			]), context).then(sub(result, context)
				context.thenCount++
				context.result = result
			end sub).catch(sub(_, context)
				context.catchCount++
			end sub).toPromise()

			return promises.onFinally(results, sub(context)
				m.testSuite.assertEqual(context, {
					thenCount: 1
					catchCount: 0
					result: [1, 2, 3]
				})
			end sub, context)
		end function

		@it("resolving works with all non-promise entires all promises")
		function _()
			context = {
				thenCount: 0
				catchCount: 0
				result: invalid
			}

			results = promises.chain(promises.all([
				1
				2
				3
			]), context).then(sub(result, context)
				context.thenCount++
				context.result = result
			end sub).catch(sub(_, context)
				context.catchCount++
			end sub).toPromise()

			return promises.onFinally(results, sub(context)
				m.testSuite.assertEqual(context, {
					thenCount: 1
					catchCount: 0
					result: [1, 2, 3]
				})
			end sub, context)
		end function

		@it("rejecting all promises")
		function _()
			context = {
				thenCount: 0
				catchCount: 0
				result: ""
			}

			results = promises.chain(promises.all([
				promises.resolve(1)
				promises.reject(2)
				promises.resolve(3)
			]), context).then(sub(_, context)
				context.thenCount++
			end sub).catch(sub(error, context)
				context.catchCount++
				context.result = error
			end sub).toPromise()

			return promises.onFinally(results, sub(context)
				m.testSuite.assertEqual(context, {
					thenCount: 0
					catchCount: 1
					result: 2
				})
			end sub, context)
		end function


		'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		@describe("promises.allSettled()")
		'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

		@it("handled non-array")
		function _()
			context = {
				thenCount: 0
				catchCount: 0
				errorMessage: ""
				backtrace: invalid
			}

			results = promises.chain(promises.allSettled(invalid), context).then(sub(_, context)
				context.thenCount++
			end sub).catch(function(error, context)
				context.catchCount++
				context.errorMessage = error.message
				context.backtrace = error.backtrace
			end function).toPromise()

			return promises.onFinally(results, sub(context)
				backtrace = context.backtrace
				context.delete("backtrace")
				m.testSuite.assertEqual(context, {
					thenCount: 0
					catchCount: 1
					errorMessage: "Did not supply an array"
				})
				m.testSuite.assertNotInvalid(backtrace)
			end sub, context)
		end function

		@it("handled empty array")
		function _()
			context = {
				thenCount: 0
				catchCount: 0
				result: invalid
			}

			results = promises.chain(promises.allSettled([]), context).then(sub(result, context)
				context.thenCount++
				context.result = result
			end sub).catch(sub(_, context)
				context.catchCount++
			end sub).toPromise()

			return promises.onFinally(results, sub(context)
				m.testSuite.assertEqual(context, {
					thenCount: 1
					catchCount: 0
					result: []
				})
			end sub, context)
		end function

		@it("resolving all promises in allSettled")
		function _()
			context = {
				thenCount: 0
				catchCount: 0
				result: invalid
			}

			results = promises.chain(promises.allSettled([
				promises.resolve(1)
				promises.resolve(2)
				promises.resolve(3)
			]), context).then(sub(result, context)
				context.thenCount++
				context.result = result
			end sub).catch(sub(_, context)
				context.catchCount++
			end sub).toPromise()

			return promises.onFinally(results, sub(context)
				m.testSuite.assertEqual(context, {
					thenCount: 1
					catchCount: 0
					result: [
						{ status: promises.PromiseState.resolved, value: 1 }
						{ status: promises.PromiseState.resolved, value: 2 }
						{ status: promises.PromiseState.resolved, value: 3 }
					]
				})
			end sub, context)
		end function

		@it("resolving works with non-promise entire in allSettled")
		function _()
			context = {
				thenCount: 0
				catchCount: 0
				result: invalid
			}

			results = promises.chain(promises.allSettled([
				promises.resolve(1)
				2
				promises.resolve(3)
			]), context).then(sub(result, context)
				context.thenCount++
				context.result = result
			end sub).catch(sub(_, context)
				context.catchCount++
			end sub).toPromise()

			return promises.onFinally(results, sub(context)
				m.testSuite.assertEqual(context, {
					thenCount: 1
					catchCount: 0
					result: [
						{ status: promises.PromiseState.resolved, value: 1 }
						{ status: promises.PromiseState.resolved, value: 2 }
						{ status: promises.PromiseState.resolved, value: 3 }
					]
				})
			end sub, context)
		end function

		@it("resolving works with all non-promise entire in allSettled")
		function _()
			context = {
				thenCount: 0
				catchCount: 0
				result: invalid
			}

			results = promises.chain(promises.allSettled([
				1
				2
				3
			]), context).then(sub(result, context)
				context.thenCount++
				context.result = result
			end sub).catch(sub(_)
				context.catchCount++
			end sub).toPromise()

			return promises.onFinally(results, sub(context)
				m.testSuite.assertEqual(context, {
					thenCount: 1
					catchCount: 0
					result: [
						{ status: promises.PromiseState.resolved, value: 1 }
						{ status: promises.PromiseState.resolved, value: 2 }
						{ status: promises.PromiseState.resolved, value: 3 }
					]
				})
			end sub, context)
		end function

		@it("rejecting a promise in allSettled")
		function _()
			context = {
				thenCount: 0
				catchCount: 0
				result: invalid
			}

			results = promises.chain(promises.allSettled([
				promises.resolve(1)
				promises.reject(2)
				promises.resolve(3)
			]), context).then(sub(result, context)
				context.thenCount++
				context.result = result
			end sub).catch(sub(_)
				context.catchCount++
			end sub).toPromise()

			return promises.onFinally(results, sub(context)
				m.testSuite.assertEqual(context, {
					thenCount: 1
					catchCount: 0
					result: [
						{ status: promises.PromiseState.resolved, value: 1 }
						{ status: promises.PromiseState.rejected, reason: 2 }
						{ status: promises.PromiseState.resolved, value: 3 }
					]
				})
			end sub, context)
		end function

		@it("rejecting all promises in allSettled")
		function _()
			context = {
				thenCount: 0
				catchCount: 0
				result: invalid
			}

			results = promises.chain(promises.allSettled([
				promises.reject(1)
				promises.reject(2)
				promises.reject(3)
			]), context).then(sub(result, context)
				context.thenCount++
				context.result = result
			end sub).catch(sub(_)
				context.catchCount++
			end sub).toPromise()

			return promises.onFinally(results, sub(context)
				m.testSuite.assertEqual(context, {
					thenCount: 1
					catchCount: 0
					result: [
						{ status: promises.PromiseState.rejected, reason: 1 }
						{ status: promises.PromiseState.rejected, reason: 2 }
						{ status: promises.PromiseState.rejected, reason: 3 }
					]
				})
			end sub, context)
		end function


		'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		@describe("promises.any()")
		'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

		@it("handled non-array")
		function _()
			context = {
				thenCount: 0
				catchCount: 0
				errors: invalid
				errorMessage: ""
				backtrace: invalid
			}

			results = promises.chain(promises.any(invalid), context).then(sub(_, context)
				context.thenCount++
			end sub).catch(sub(error, context)
				context.catchCount++
				context.errors = error.errors
				context.errorMessage = error.message
				context.backtrace = error.backtrace
			end sub).toPromise()

			return promises.onFinally(results, sub(context)
				backtrace = context.backtrace
				context.delete("backtrace")
				m.testSuite.assertEqual(context, {
					thenCount: 0
					catchCount: 1
					errors: []
					errorMessage: "All promises were rejected"
				})
				m.testSuite.assertNotInvalid(backtrace)
			end sub, context)
		end function

		@it("handled empty array")
		function _()
			context = {
				thenCount: 0
				catchCount: 0
				errors: invalid
				errorMessage: ""
				backtrace: invalid
			}

			results = promises.chain(promises.any([]), context).then(sub(_, context)
				context.thenCount++
			end sub).catch(sub(error, context)
				context.catchCount++
				context.errors = error.errors
				context.errorMessage = error.message
				context.backtrace = error.backtrace
			end sub).toPromise()

			return promises.onFinally(results, sub(context)
				backtrace = context.backtrace
				context.delete("backtrace")
				m.testSuite.assertEqual(context, {
					thenCount: 0
					catchCount: 1
					errors: []
					errorMessage: "All promises were rejected"
				})
				m.testSuite.assertNotInvalid(backtrace)
			end sub, context)
		end function

		@async
		@it("handled a promise that resolves")
		sub _()
			promiseArray = [
				promises.create()
				promises.create()
				promises.create()
			]

			promises.chain(promises.any(promiseArray), promiseArray).then(sub(result, promiseArray)
				m.testSuite.assertEqual(result, 2)
			end sub).catch(sub(_, promiseArray)
				m.testSuite.fail("should not get here")
			end sub).finally(sub(promiseArray)
				promises.resolve(invalid, promiseArray[0])
				promises.resolve(invalid, promiseArray[2])

				m.testSuite.done()
			end sub)

			promises.resolve(2, promiseArray[1])
		end sub

		@it("handles a pre-resolved promise")
		function _()
			promiseArray = [
				promises.create()
				promises.resolve(2)
				promises.create()
			]

			return promises.chain(promises.any(promiseArray), promiseArray).then(sub(result, promiseArray)
				m.testSuite.assertEqual(result, 2)
			end sub).catch(sub(_, promiseArray)
				m.testSuite.fail("should not get here")
			end sub).finally(sub(promiseArray)
				promises.resolve(invalid, promiseArray[0])
				promises.resolve(invalid, promiseArray[2])
			end sub).toPromise()
		end function

		@it("handles a non-promise value amongst pending promises")
		function _()
			promiseArray = [
				promises.create()
				2
				promises.create()
			]

			return promises.chain(promises.any(promiseArray), promiseArray).then(sub(result, promiseArray)
				m.testSuite.assertEqual(result, 2)
			end sub).catch(sub(_, promiseArray)
				m.testSuite.fail("should not get here")
			end sub).finally(sub(promiseArray)
				promises.resolve(invalid, promiseArray[0])
				promises.resolve(invalid, promiseArray[2])
			end sub).toPromise()
		end function

		@it("handles a non-promise value amongst rejected promises")
		function _()
			promiseArray = [
				promises.reject(1)
				2
				promises.reject(2)
			]

			return promises.chain(promises.any(promiseArray), promiseArray).then(sub(result, promiseArray)
				m.testSuite.assertEqual(result, 2)
			end sub).catch(sub(_, promiseArray)
				m.testSuite.fail("should not get here")
			end sub).toPromise()
		end function

		@it("handles a first pre-resolved promise")
		function _()
			promiseArray = [
				promises.resolve(1)
				promises.resolve(2)
				promises.resolve(2)
			]

			return promises.chain(promises.any(promiseArray), promiseArray).then(sub(result, promiseArray)
				m.testSuite.assertEqual(result, 1)
			end sub).catch(sub(_, promiseArray)
				m.testSuite.fail("should not get here")
			end sub).toPromise()
		end function

		@async
		@it("handles first pre-resolved promise along with a non-promise value")
		function _()
			promiseArray = [
				promises.resolve(1)
				2
				promises.resolve(2)
			]

			return promises.chain(promises.any(promiseArray), promiseArray).then(sub(result, promiseArray)
				m.testSuite.assertEqual(result, 1)
			end sub).catch(sub(_, promiseArray)
				m.testSuite.fail("should not get here")
			end sub).toPromise()
		end function

		@it("handles all promises being pre-rejected")
		function _()
			promiseArray = [
				promises.reject("1")
				promises.reject("2")
				promises.reject("3")
			]

			return promises.chain(promises.any(promiseArray), promiseArray).then(sub(result, promiseArray)
				m.testSuite.fail("should not get here")
			end sub).catch(sub(error, promiseArray)
				m.testSuite.assertEqual(error.message, "All promises were rejected")
				m.testSuite.assertEqual(error.errors, ["1", "2", "3"])
				m.testSuite.assertNotInvalid(error.backtrace)
			end sub).toPromise()
		end function

		'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		@describe("promises.race()")
		'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

		@it("handled non-array")
		function _()
			return promises.chain(promises.race(invalid)).then(sub(result)
				m.testSuite.fail("should not get here")
			end sub).catch(sub(error)
				m.testSuite.assertEqual(error.message, "All promises were rejected")
				m.testSuite.assertEqual(error.errors, [])
				m.testSuite.assertNotInvalid(error.backtrace)
			end sub).toPromise()
		end function

		@it("handled empty array")
		function _()
			return promises.chain(promises.race([])).then(sub(result)
				m.testSuite.fail("should not get here")
			end sub).catch(sub(error)
				m.testSuite.assertEqual(error.message, "All promises were rejected")
				m.testSuite.assertEqual(error.errors, [])
				m.testSuite.assertNotInvalid(error.backtrace)
			end sub).toPromise()
		end function

		@async
		@it("handled a promise that resolves")
		sub _()
			promiseArray = [
				promises.create()
				promises.create()
				promises.create()
			]

			promises.chain(promises.race(promiseArray), promiseArray).then(sub(result, promiseArray)
				m.testSuite.assertEqual(result, 2)
			end sub).catch(sub(_, promiseArray)
				m.testSuite.fail("should not get here")
			end sub).finally(sub(promiseArray)
				promises.resolve(invalid, promiseArray[0])
				promises.resolve(invalid, promiseArray[2])

				m.testSuite.done()
			end sub)

			promises.resolve(2, promiseArray[1])
		end sub

		@it("handles a pre-resolved promise")
		function _()
			promiseArray = [
				promises.create()
				promises.resolve(2)
				promises.create()
			]

			return promises.chain(promises.race(promiseArray), promiseArray).then(sub(result, promiseArray)
				m.testSuite.assertEqual(result, 2)
			end sub).catch(sub(_, promiseArray)
				m.testSuite.fail("should not get here")
			end sub).finally(sub(promiseArray)
				promises.resolve(invalid, promiseArray[0])
				promises.resolve(invalid, promiseArray[2])
			end sub).toPromise()
		end function

		@it("handles a non-promise value amongst pending promises")
		function _()
			promiseArray = [
				promises.create()
				2
				promises.create()
			]

			promises.chain(promises.race(promiseArray), promiseArray).then(sub(result, promiseArray)
				m.testSuite.assertEqual(result, 2)
			end sub).catch(sub(_, promiseArray)
				m.testSuite.fail("should not get here")
			end sub).finally(sub(promiseArray)
				promises.resolve(invalid, promiseArray[0])
				promises.resolve(invalid, promiseArray[2])
			end sub).toPromise()
		end function

		@it("handles a non-promise value amongst rejected promises")
		function _()
			promiseArray = [
				promises.reject(1)
				2
				promises.reject(3)
			]

			return promises.chain(promises.race(promiseArray), promiseArray).then(sub(result, promiseArray)
				m.testSuite.fail("should not get here")
			end sub).catch(sub(error, promiseArray)
				m.testSuite.assertEqual(error, 1)
			end sub).toPromise()
		end function

		@it("handles a first pre-resolved promise")
		function _()
			promiseArray = [
				promises.resolve(1)
				promises.resolve(2)
				promises.resolve(3)
			]

			return promises.chain(promises.race(promiseArray), promiseArray).then(sub(result, promiseArray)
				m.testSuite.assertEqual(result, 1)
			end sub).catch(sub(_, promiseArray)
				m.testSuite.fail("should not get here")
			end sub).toPromise()
		end function

		@it("handles first pre-resolved promise along with a non-promise value")
		function _()
			promiseArray = [
				promises.resolve(1)
				2
				promises.resolve(3)
			]

			return promises.chain(promises.race(promiseArray), promiseArray).then(sub(result, promiseArray)
				m.testSuite.assertEqual(result, 1)
			end sub).catch(sub(_, promiseArray)
				m.testSuite.fail("should not get here")
			end sub).toPromise()
		end function

		@it("handles all promises being pre-rejected")
		function _()
			promiseArray = [
				promises.reject("1")
				promises.reject("2")
				promises.reject("3")
			]

			return promises.chain(promises.race(promiseArray), promiseArray).then(sub(result, promiseArray)
				m.testSuite.fail("should not get here")
			end sub).catch(sub(error, promiseArray)
				m.testSuite.assertEqual(error, "1")
			end sub).toPromise()
		end function

		@it("handled a the first promise to resolve")
		function _()
			promiseArray = [
				toPromiseWithDelay(0.3, 1)
				toPromiseWithDelay(0.2, 2)
				toPromiseWithDelay(0.1, 3)
			]

			promises.chain(promises.race(promiseArray), promiseArray).then(sub(result, promiseArray)
				m.testSuite.assertEqual(result, 3)
			end sub).catch(sub(_, promiseArray)
				m.testSuite.fail("should not get here")
			end sub).toPromise()
		end function

		@it("handled a the first promise to reject")
		function _()
			promiseArray = [
				toPromiseWithDelay(0.2, 1)
				toPromiseWithDelay(0.1, 2, false)
				toPromiseWithDelay(0.3, 3)
			]

			promises.chain(promises.race(promiseArray), promiseArray).then(sub(result, promiseArray)
				m.testSuite.fail("should not get here")
			end sub).catch(sub(error, promiseArray)
				m.testSuite.assertEqual(error, 2)
			end sub).toPromise()
		end function

		'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		@describe("promises.onThen()")
		'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

		@async
		@it("catches resolved promises")
		sub _()
			promises.onThen(promises.resolve("resolved"), sub(value)
				m.testSuite.assertEqual(value, "resolved")
				m.testSuite.done()
			end sub)
		end sub

		@async
		@it("recovered on wrong num of callback args")
		sub _()
			context = {}
			promises.onThen(promises.resolve("resolved"), sub(value)
				m.testSuite.assertEqual(value, "resolved")
				m.testSuite.done()
			end sub, context)
		end sub

		@async
		@it("handles empty callbacks")
		sub _()
			promises.onThen(promises.onThen(promises.resolve("resolved")), sub(value)
				m.testSuite.assertEqual(value, "resolved")
				m.testSuite.done()
			end sub)
		end sub

		@async
		@it("does not response to rejected promises")
		sub _()
			context = { thenCount: 0 }

			promise = promises.onThen(promises.reject("rejected"), sub(value, context)
				context.thenCount++
			end sub, context)

			promises.onFinally(promise, sub(context)
				m.testSuite.assertEqual(context, { thenCount: 0 })
				m.testSuite.done()
			end sub, context)
		end sub

		'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		@describe("promises.onCatch()")
		'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

		@async
		@it("catches rejected promises")
		sub _()
			promises.onCatch(promises.reject("rejected"), sub(value)
				m.testSuite.assertEqual(value, "rejected")
				m.testSuite.done()
			end sub)
		end sub

		@async
		@it("recovered on wrong num of callback args")
		sub _()
			context = {}
			promises.onCatch(promises.reject("rejected"), sub(value)
				m.testSuite.assertEqual(value, "rejected")
				m.testSuite.done()
			end sub, context)
		end sub

		@async
		@it("handles empty callbacks")
		sub _()
			promises.onCatch(promises.onCatch(promises.reject("rejected")), sub(value)
				m.testSuite.assertEqual(value, "rejected")
				m.testSuite.done()
			end sub)
		end sub

		@async
		@it("does not response to resolved promises")
		sub _()
			context = { catchCount: 0 }

			promise = promises.onCatch(promises.resolve("resolved"), sub(value, context)
				context.catchCount++
			end sub, context)

			promises.onFinally(promise, sub(context)
				m.testSuite.assertEqual(context, { catchCount: 0 })
				m.testSuite.done()
			end sub, context)
		end sub

		'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		@describe("promises.onFinally()")
		'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

		@async
		@it("handles resolved promise")
		sub _()
			promise = promises.onFinally(promises.resolve("resolved"), sub()
			end sub)

			promises.onThen(promise, sub(value)
				m.testSuite.assertEqual(value, "resolved")
				m.testSuite.done()
			end sub)
		end sub

		@async
		@it("recovered on wrong num of callback args")
		sub _()
			context = {}
			promises.onFinally(promises.resolve("resolved"), sub()
				m.testSuite.done()
			end sub, context)
		end sub

		@async
		@it("handles resolved promise with empty callback")
		sub _()
			promise = promises.onFinally(promises.onFinally(promises.resolve("resolved")), sub()
			end sub)

			promises.onThen(promise, sub(value)
				m.testSuite.assertEqual(value, "resolved")
				m.testSuite.done()
			end sub)
		end sub

		@async
		@it("handles rejected promise")
		sub _()
			promise = promises.onFinally(promises.reject("rejected"), sub()
			end sub)

			promises.onCatch(promise, sub(value)
				m.testSuite.assertEqual(value, "rejected")
				m.testSuite.done()
			end sub)
		end sub

		@async
		@it("handles rejected promise with empty callback")
		sub _()
			promise = promises.onFinally(promises.onFinally(promises.reject("rejected")), sub()
			end sub)

			promises.onCatch(promise, sub(value)
				m.testSuite.assertEqual(value, "rejected")
				m.testSuite.done()
			end sub)
		end sub

		@async
		@it("handles returning as rejected promise from the finally")
		sub _()
			promise = promises.onFinally(promises.reject("rejected"), function()
				return promises.reject("new rejected promise")
			end function)

			promises.onCatch(promise, sub(value)
				m.testSuite.assertEqual(value, "new rejected promise")
				m.testSuite.done()
			end sub)
		end sub

		@async
		@it("handles rejecting with a crash in the finally")
		sub _()
			promise = promises.onFinally(promises.reject("rejected"), sub()
				throw "new rejected promise"
			end sub)

			promises.onCatch(promise, sub(value)
				m.testSuite.assertEqual(value.message, "new rejected promise")
				m.testSuite.assertNotInvalid(value.backtrace)
				m.testSuite.done()
			end sub)
		end sub

		'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		@describe("promises.enableCrashLogging()")
		'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

		@beforeEach
		sub beforeEachenableCrashLogging()
			m.global.removeField("__promises__crashLoggingEnabled")
			m.node.delete("formatStackTraceCalled")
		end sub

		@afterEach
		sub afterEachenableCrashLogging()
			m.global.removeField("__promises__crashLoggingEnabled")
			m.node.delete("formatStackTraceCalled")
		end sub

		@it("properly adds and removes the setting from global")
		function _()
			m.assertFalse(m.global.hasField("__promises__crashLoggingEnabled"))
			promises.configuration.enableCrashLogging(true)
			m.assertNodeContainsFields(m.global, { "__promises__crashLoggingEnabled": true })
			promises.configuration.enableCrashLogging(false)
			m.assertFalse(m.global.hasField("__promises__crashLoggingEnabled"))
		end function

		@it("enableCrashLogging(true) onThen() no context provided")
		function _()
			promises.configuration.enableCrashLogging(true)

			m.node.formatStackTraceCalled = 0
			m.stubCall(promises.internal.formatStackTrace, function(error, message)
				m.testSuite.assertNotInvalid(error.message)
				m.testSuite.assertNotInvalid(error.backtrace)
				m.testSuite.assertEqual(message, "my error")
				m.formatStackTraceCalled++
				return ""
			end function)

			return promises.chain(promises.resolve("resolved")).then(sub(value)
				throw "my error"
			end sub).catch(sub(error)
				m.testSuite.assertEqual(m.formatStackTraceCalled, 1)
			end sub).toPromise()
		end function

		@it("enableCrashLogging(true) onThen() context was provided")
		function _()
			promises.configuration.enableCrashLogging(true)

			m.node.formatStackTraceCalled = 0
			m.stubCall(promises.internal.formatStackTrace, function(_, _)
				m.formatStackTraceCalled++
				return ""
			end function)

			return promises.chain(promises.resolve("resolved"), {}).then(sub(value, context)
				test = 1/0
			end sub).catch(sub(error, context)
				m.testSuite.assertEqual(m.formatStackTraceCalled, 1)
			end sub).toPromise()
		end function

		@it("enableCrashLogging(true) onCatch() no context provided")
		function _()
			promises.configuration.enableCrashLogging(true)

			m.node.formatStackTraceCalled = 0
			m.stubCall(promises.internal.formatStackTrace, function(_, _)
				m.formatStackTraceCalled++
				return ""
			end function)

			return promises.chain(promises.reject("rejected")).catch(sub(error)
				test = 1/0
			end sub).catch(sub(error)
				m.testSuite.assertEqual(m.formatStackTraceCalled, 1)
			end sub).toPromise()
		end function

		@it("enableCrashLogging(true) onCatch() context was provided")
		function _()
			promises.configuration.enableCrashLogging(true)

			m.node.formatStackTraceCalled = 0
			m.stubCall(promises.internal.formatStackTrace, function(_, _)
				m.formatStackTraceCalled++
				return ""
			end function)

			return promises.chain(promises.reject("rejected"), {}).catch(sub(error, context)
				test = 1/0
			end sub).catch(sub(error, context)
				m.testSuite.assertEqual(m.formatStackTraceCalled, 1)
			end sub).toPromise()
		end function

		@it("enableCrashLogging(true) onFinally() no context provided")
		function _()
			promises.configuration.enableCrashLogging(true)

			m.node.formatStackTraceCalled = 0
			m.stubCall(promises.internal.formatStackTrace, function(_, _)
				m.formatStackTraceCalled++
				return ""
			end function)

			return promises.chain(promises.resolve("resolved")).finally(sub()
				test = 1/0
			end sub).catch(sub(error)
				m.testSuite.assertEqual(m.formatStackTraceCalled, 1)
			end sub).toPromise()
		end function

		@it("enableCrashLogging(true) onFinally() context was provided")
		function _()
			promises.configuration.enableCrashLogging(true)

			m.node.formatStackTraceCalled = 0
			m.stubCall(promises.internal.formatStackTrace, function(_, _)
				m.formatStackTraceCalled++
				return ""
			end function)

			return promises.chain(promises.resolve("resolved"), {}).finally(sub(context)
				test = 1/0
			end sub).catch(sub(error, context)
				m.testSuite.assertEqual(m.formatStackTraceCalled, 1)
			end sub).toPromise()
		end function

		'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		@describe("does not resolve to soon or too late")
		'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

		@async
		@it("timer promise")
		function _()
			timerDurationInMillis = 125
			promise = sleepPromise(timerDurationInMillis / 1000)
			promises.onThen(promise, sub(_ as dynamic, ctx as dynamic)
				elapsedTimeInMillis = ctx.timespan.totalMilliseconds()
				? "elapsed time to resolve promise:" + elapsedTimeInMillis.tostr()
				tolerance = ctx.timerDurationInMillis * 0.2
				msg = "did not settle within 10% tolerance of timer duration"
				m.testSuite.assertTrue(ctx.timerDurationInMillis - tolerance <= elapsedTimeInMillis, msg)
				m.testSuite.assertTrue(ctx.timerDurationInMillis + tolerance >= elapsedTimeInMillis, msg)
				m.testSuite.done()
			end sub, {
				timespan: createObject("roTimespan")
				timerDurationInMillis: timerDurationInMillis
			})
		end function

		'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		@describe("promises.try()")
		'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

		@it("returns a the same promise if the callback returns a promise")
		function _()
			resolvedPromiseParam = promises.resolve(1)
			resolvedPromise = promises.try(function(arg)
				return arg
			end function, [resolvedPromiseParam])

			m.assertTrue(promises.isPromise(resolvedPromise))
			m.assertTrue(resolvedPromise.isSameNode(resolvedPromiseParam))

			rejectedPromiseParam = promises.reject("error")
			rejectedPromise = promises.try(function(arg)
				return arg
			end function, [rejectedPromiseParam])

			m.assertTrue(promises.isPromise(rejectedPromise))
			m.assertTrue(rejectedPromise.isSameNode(rejectedPromiseParam))

			return promises.onThen(promises.allSettled([resolvedPromise, rejectedPromise]), sub(results)
				m.testSuite.assertEqual(results, [
					{ status: promises.PromiseState.resolved, value: 1 }
					{ status: promises.PromiseState.rejected, reason: "error" }
				])
			end sub)
		end function

		@it("returns a rejected promise if the callback throws an error")
		function _()
			promise = promises.try(function()
				throw "error"
			end function)

			m.assertTrue(promises.isPromise(promise))

			return promises.onCatch(promise, sub(error)
				m.testSuite.assertEqual(error.message, "error")
				m.testSuite.assertNotInvalid(error.backTrace)
			end sub)
		end function

		@it("calls the callback when supplied with no augments wrapped in a promise")
		function _()
			promise = promises.try(function()
				return true
			end function)

			m.assertTrue(promises.isPromise(promise))

			return promises.onThen(promise, sub(result)
				m.testSuite.assertEqual(result, true)
			end sub)
		end function


		@it("calls the callback when supplied empty augments")
		function _()
			promise = promises.try(function()
				return true
			end function, [])

			return promises.onThen(promise, sub(result)
				m.testSuite.assertEqual(result, true)
			end sub)
		end function

		@it("calls the callback when supplied with 1 augment")
		function _()
			promise = promises.try(function(a)
				return [a]
			end function, [1])

			return promises.onThen(promise, sub(result)
				m.testSuite.assertEqual(result, [1])
			end sub)
		end function

		@it("calls the callback when supplied with 2 augments")
		function _()
			promise = promises.try(function(a, b)
				return [a, b]
			end function, [1, 2])

			return promises.onThen(promise, sub(result)
				m.testSuite.assertEqual(result, [1, 2])
			end sub)
		end function

		@it("calls the callback when supplied with 3 augments")
		function _()
			promise = promises.try(function(a, b, c)
				return [a, b, c]
			end function, [1, 2, 3])

			return promises.onThen(promise, sub(result)
				m.testSuite.assertEqual(result, [1, 2, 3])
			end sub)
		end function

		@it("calls the callback when supplied with 4 augments")
		function _()
			promise = promises.try(function(a, b, c, d)
				return [a, b, c, d]
			end function, [1, 2, 3, 4])

			return promises.onThen(promise, sub(result)
				m.testSuite.assertEqual(result, [1, 2, 3, 4])
			end sub)
		end function

		@it("calls the callback when supplied with 5 augments")
		function _()
			promise = promises.try(function(a, b, c, d, e)
				return [a, b, c, d, e]
			end function, [1, 2, 3, 4, 5])

			return promises.onThen(promise, sub(result)
				m.testSuite.assertEqual(result, [1, 2, 3, 4, 5])
			end sub)
		end function

		@it("calls the callback when supplied with 6 augments")
		function _()
			promise = promises.try(function(a, b, c, d, e, f)
				return [a, b, c, d, e, f]
			end function, [1, 2, 3, 4, 5, 6])

			return promises.onThen(promise, sub(result)
				m.testSuite.assertEqual(result, [1, 2, 3, 4, 5, 6])
			end sub)
		end function

		@it("calls the callback when supplied with 7 augments")
		function _()
			promise = promises.try(function(a, b, c, d, e, f, g)
				return [a, b, c, d, e, f, g]
			end function, [1, 2, 3, 4, 5, 6, 7])

			return promises.onThen(promise, sub(result)
				m.testSuite.assertEqual(result, [1, 2, 3, 4, 5, 6, 7])
			end sub)
		end function

		@it("calls the callback when supplied with 8 augments")
		function _()
			promise = promises.try(function(a, b, c, d, e, f, g, h)
				return [a, b, c, d, e, f, g, h]
			end function, [1, 2, 3, 4, 5, 6, 7, 8])

			return promises.onThen(promise, sub(result)
				m.testSuite.assertEqual(result, [1, 2, 3, 4, 5, 6, 7, 8])
			end sub)
		end function

		@it("calls the callback when supplied with 9 augments")
		function _()
			promise = promises.try(function(a, b, c, d, e, f, g, h, i)
				return [a, b, c, d, e, f, g, h, i]
			end function, [1, 2, 3, 4, 5, 6, 7, 8, 9])

			return promises.onThen(promise, sub(result)
				m.testSuite.assertEqual(result, [1, 2, 3, 4, 5, 6, 7, 8, 9])
			end sub)
		end function

		@it("calls the callback when supplied with 10 augments")
		function _()
			promise = promises.try(function(a, b, c, d, e, f, g, h, i, j)
				return [a, b, c, d, e, f, g, h, i, j]
			end function, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])

			return promises.onThen(promise, sub(result)
				m.testSuite.assertEqual(result, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
			end sub)
		end function

		@it("calls the callback when supplied with 11 augments")
		function _()
			promise = promises.try(function(a, b, c, d, e, f, g, h, i, j, k)
				return [a, b, c, d, e, f, g, h, i, j, k]
			end function, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])

			return promises.onThen(promise, sub(result)
				m.testSuite.assertEqual(result, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
			end sub)
		end function

		@it("calls the callback when supplied with 12 augments")
		function _()
			promise = promises.try(function(a, b, c, d, e, f, g, h, i, j, k, l)
				return [a, b, c, d, e, f, g, h, i, j, k, l]
			end function, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])

			return promises.onThen(promise, sub(result)
				m.testSuite.assertEqual(result, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])
			end sub)
		end function

		@it("calls the callback when supplied with 13 augments")
		function _()
			promise = promises.try(function(a, b, c, d, e, f, g, h, i, j, k, l, mm)
				return [a, b, c, d, e, f, g, h, i, j, k, l, mm]
			end function, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13])

			return promises.onThen(promise, sub(result)
				m.testSuite.assertEqual(result, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13])
			end sub)
		end function

		@it("calls the callback when supplied with 14 augments")
		function _()
			promise = promises.try(function(a, b, c, d, e, f, g, h, i, j, k, l, mm, n)
				return [a, b, c, d, e, f, g, h, i, j, k, l, mm, n]
			end function, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])

			return promises.onThen(promise, sub(result)
				m.testSuite.assertEqual(result, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])
			end sub)
		end function

		@it("calls the callback when supplied with 15 augments")
		function _()
			promise = promises.try(function(a, b, c, d, e, f, g, h, i, j, k, l, mm, n, o)
				return [a, b, c, d, e, f, g, h, i, j, k, l, mm, n, o]
			end function, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])

			return promises.onThen(promise, sub(result)
				m.testSuite.assertEqual(result, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])
			end sub)
		end function

		@it("calls the callback when supplied with 16 augments")
		function _()
			promise = promises.try(function(a, b, c, d, e, f, g, h, i, j, k, l, mm, n, o, p)
				return [a, b, c, d, e, f, g, h, i, j, k, l, mm, n, o, p]
			end function, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16])

			return promises.onThen(promise, sub(result)
				m.testSuite.assertEqual(result, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16])
			end sub)
		end function

		@it("calls the callback when supplied with 17 augments")
		function _()
			promise = promises.try(function(a, b, c, d, e, f, g, h, i, j, k, l, mm, n, o, p, q)
				return [a, b, c, d, e, f, g, h, i, j, k, l, mm, n, o, p, q]
			end function, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17])

			return promises.onThen(promise, sub(result)
				m.testSuite.assertEqual(result, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17])
			end sub)
		end function

		@it("calls the callback when supplied with 18 augments")
		function _()
			promise = promises.try(function(a, b, c, d, e, f, g, h, i, j, k, l, mm, n, o, p, q, r)
				return [a, b, c, d, e, f, g, h, i, j, k, l, mm, n, o, p, q, r]
			end function, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18])

			return promises.onThen(promise, sub(result)
				m.testSuite.assertEqual(result, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18])
			end sub)
		end function

		@it("calls the callback when supplied with 19 augments")
		function _()
			promise = promises.try(function(a, b, c, d, e, f, g, h, i, j, k, l, mm, n, o, p, q, r, s)
				return [a, b, c, d, e, f, g, h, i, j, k, l, mm, n, o, p, q, r, s]
			end function, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19])

			return promises.onThen(promise, sub(result)
				m.testSuite.assertEqual(result, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19])
			end sub)
		end function

		@it("calls the callback when supplied with 20 augments")
		function _()
			promise = promises.try(function(a, b, c, d, e, f, g, h, i, j, k, l, mm, n, o, p, q, r, s, t)
				return [a, b, c, d, e, f, g, h, i, j, k, l, mm, n, o, p, q, r, s, t]
			end function, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])

			return promises.onThen(promise, sub(result)
				m.testSuite.assertEqual(result, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])
			end sub)
		end function

		@it("calls the callback when supplied with 21 augments")
		function _()
			promise = promises.try(function(a, b, c, d, e, f, g, h, i, j, k, l, mm, n, o, p, q, r, s, t, u)
				return [a, b, c, d, e, f, g, h, i, j, k, l, mm, n, o, p, q, r, s, t, u]
			end function, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21])

			return promises.onThen(promise, sub(result)
				m.testSuite.assertEqual(result, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21])
			end sub)
		end function

		@it("calls the callback when supplied with 22 augments")
		function _()
			promise = promises.try(function(a, b, c, d, e, f, g, h, i, j, k, l, mm, n, o, p, q, r, s, t, u, v)
				return [a, b, c, d, e, f, g, h, i, j, k, l, mm, n, o, p, q, r, s, t, u, v]
			end function, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22])

			return promises.onThen(promise, sub(result)
				m.testSuite.assertEqual(result, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22])
			end sub)
		end function

		@it("calls the callback when supplied with 23 augments")
		function _()
			promise = promises.try(function(a, b, c, d, e, f, g, h, i, j, k, l, mm, n, o, p, q, r, s, t, u, v, w)
				return [a, b, c, d, e, f, g, h, i, j, k, l, mm, n, o, p, q, r, s, t, u, v, w]
			end function, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23])

			return promises.onThen(promise, sub(result)
				m.testSuite.assertEqual(result, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23])
			end sub)
		end function

		@it("calls the callback when supplied with 24 augments")
		function _()
			promise = promises.try(function(a, b, c, d, e, f, g, h, i, j, k, l, mm, n, o, p, q, r, s, t, u, v, w, x)
				return [a, b, c, d, e, f, g, h, i, j, k, l, mm, n, o, p, q, r, s, t, u, v, w, x]
			end function, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24])

			return promises.onThen(promise, sub(result)
				m.testSuite.assertEqual(result, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24])
			end sub)
		end function

		@it("calls the callback when supplied with 25 augments")
		function _()
			promise = promises.try(function(a, b, c, d, e, f, g, h, i, j, k, l, mm, n, o, p, q, r, s, t, u, v, w, x, y)
				return [a, b, c, d, e, f, g, h, i, j, k, l, mm, n, o, p, q, r, s, t, u, v, w, x, y]
			end function, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25])

			return promises.onThen(promise, sub(result)
				m.testSuite.assertEqual(result, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25])
			end sub)
		end function

		@it("calls the callback when supplied with 26 augments")
		function _()
			promise = promises.try(function(a, b, c, d, e, f, g, h, i, j, k, l, mm, n, o, p, q, r, s, t, u, v, w, x, y, z)
				return [a, b, c, d, e, f, g, h, i, j, k, l, mm, n, o, p, q, r, s, t, u, v, w, x, y, z]
			end function, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26])

			return promises.onThen(promise, sub(result)
				m.testSuite.assertEqual(result, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26])
			end sub)
		end function

		@it("calls the callback when supplied with 27 augments")
		function _()
			promise = promises.try(function(a, b, c, d, e, f, g, h, i, j, k, l, mm, n, o, p, q, r, s, t, u, v, w, x, y, z, aa)
				return [a, b, c, d, e, f, g, h, i, j, k, l, mm, n, o, p, q, r, s, t, u, v, w, x, y, z, aa]
			end function, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27])

			return promises.onThen(promise, sub(result)
				m.testSuite.assertEqual(result, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27])
			end sub)
		end function

		@it("calls the callback when supplied with 28 augments")
		function _()
			promise = promises.try(function(a, b, c, d, e, f, g, h, i, j, k, l, mm, n, o, p, q, r, s, t, u, v, w, x, y, z, aa, ab)
				return [a, b, c, d, e, f, g, h, i, j, k, l, mm, n, o, p, q, r, s, t, u, v, w, x, y, z, aa, ab]
			end function, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28])

			return promises.onThen(promise, sub(result)
				m.testSuite.assertEqual(result, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28])
			end sub)
		end function

		@it("calls the callback when supplied with 29 augments")
		function _()
			promise = promises.try(function(a, b, c, d, e, f, g, h, i, j, k, l, mm, n, o, p, q, r, s, t, u, v, w, x, y, z, aa, ab, ac)
				return [a, b, c, d, e, f, g, h, i, j, k, l, mm, n, o, p, q, r, s, t, u, v, w, x, y, z, aa, ab, ac]
			end function, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29])

			return promises.onThen(promise, sub(result)
				m.testSuite.assertEqual(result, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29])
			end sub)
		end function

		@it("calls the callback when supplied with 30 augments")
		function _()
			promise = promises.try(function(a, b, c, d, e, f, g, h, i, j, k, l, mm, n, o, p, q, r, s, t, u, v, w, x, y, z, aa, ab, ac, ad)
				return [a, b, c, d, e, f, g, h, i, j, k, l, mm, n, o, p, q, r, s, t, u, v, w, x, y, z, aa, ab, ac, ad]
			end function, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30])

			return promises.onThen(promise, sub(result)
				m.testSuite.assertEqual(result, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30])
			end sub)
		end function

		@it("calls the callback when supplied with 31 augments")
		function _()
			promise = promises.try(function(a, b, c, d, e, f, g, h, i, j, k, l, mm, n, o, p, q, r, s, t, u, v, w, x, y, z, aa, ab, ac, ad, ae)
				return [a, b, c, d, e, f, g, h, i, j, k, l, mm, n, o, p, q, r, s, t, u, v, w, x, y, z, aa, ab, ac, ad, ae]
			end function, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31])

			return promises.onThen(promise, sub(result)
				m.testSuite.assertEqual(result, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31])
			end sub)
		end function

		@it("calls the callback when supplied with 32 augments")
		function _()
			promise = promises.try(function(a, b, c, d, e, f, g, h, i, j, k, l, mm, n, o, p, q, r, s, t, u, v, w, x, y, z, aa, ab, ac, ad, ae, af)
				return [a, b, c, d, e, f, g, h, i, j, k, l, mm, n, o, p, q, r, s, t, u, v, w, x, y, z, aa, ab, ac, ad, ae, af]
			end function, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32])

			return promises.onThen(promise, sub(result)
				m.testSuite.assertEqual(result, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32])
			end sub)
		end function

		'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		@describe("promises.resolve()/promises.reject()")
		'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

		@async
		@it("resolved invalid")
		function _()
			promise = promises.resolve(invalid)
			promises.onThen(promise, sub(result as dynamic)
				m.testSuite.assertEqual(result, invalid)
				m.testSuite.done()
			end sub)
		end function

		@async
		@it("reject invalid")
		function _()
			promise = promises.reject(invalid)
			promises.onCatch(promise, sub(result as dynamic)
				m.testSuite.assertEqual(result, invalid)
				m.testSuite.done()
			end sub)
		end function

		@async
		@it("resolved integer")
		function _()
			promise = promises.resolve(1)
			promises.onThen(promise, sub(result as dynamic)
				m.testSuite.assertEqual(result, 1)
				m.testSuite.done()
			end sub)
		end function

		@async
		@it("reject integer")
		function _()
			promise = promises.reject(1)
			promises.onCatch(promise, sub(result as dynamic)
				m.testSuite.assertEqual(result, 1)
				m.testSuite.done()
			end sub)
		end function

		@async
		@it("resolved float")
		function _()
			promise = promises.resolve(1.1)
			promises.onThen(promise, sub(result as dynamic)
				m.testSuite.assertEqual(result, 1.1)
				m.testSuite.done()
			end sub)
		end function

		@async
		@it("reject float")
		function _()
			promise = promises.reject(1.1)
			promises.onCatch(promise, sub(result as dynamic)
				m.testSuite.assertEqual(result, 1.1)
				m.testSuite.done()
			end sub)
		end function

		@async
		@it("resolved boolean")
		function _()
			promise = promises.resolve(true)
			promises.onThen(promise, sub(result as dynamic)
				m.testSuite.assertEqual(result, true)
				m.testSuite.done()
			end sub)
		end function

		@async
		@it("reject boolean")
		function _()
			promise = promises.reject(true)
			promises.onCatch(promise, sub(result as dynamic)
				m.testSuite.assertEqual(result, true)
				m.testSuite.done()
			end sub)
		end function

		@async
		@it("resolved string")
		function _()
			promise = promises.resolve("my string")
			promises.onThen(promise, sub(result as dynamic)
				m.testSuite.assertEqual(result, "my string")
				m.testSuite.done()
			end sub)
		end function

		@async
		@it("reject string")
		function _()
			promise = promises.reject("my string")
			promises.onCatch(promise, sub(result as dynamic)
				m.testSuite.assertEqual(result, "my string")
				m.testSuite.done()
			end sub)
		end function

		@async
		@it("resolved array")
		function _()
			promise = promises.resolve([1, 2, 3])
			promises.onThen(promise, sub(result as dynamic)
				m.testSuite.assertEqual(result, [1, 2, 3])
				m.testSuite.done()
			end sub)
		end function

		@async
		@it("reject array")
		function _()
			promise = promises.reject([1, 2, 3])
			promises.onCatch(promise, sub(result as dynamic)
				m.testSuite.assertEqual(result, [1, 2, 3])
				m.testSuite.done()
			end sub)
		end function

		@async
		@it("resolved AA")
		function _()
			promise = promises.resolve({
				key: "value"
			})
			promises.onThen(promise, sub(result as dynamic)
				m.testSuite.assertEqual(result, {
					key: "value"
				})
				m.testSuite.done()
			end sub)
		end function

		@async
		@it("reject AA")
		function _()
			promise = promises.reject({
				key: "value"
			})
			promises.onCatch(promise, sub(result as dynamic)
				m.testSuite.assertEqual(result, {
					key: "value"
				})
				m.testSuite.done()
			end sub)
		end function

		@async
		@it("resolved AA with subtype")
		function _()
			promise = promises.resolve({
				subType: "Node"
			})
			promises.onThen(promise, sub(result as dynamic)
				m.testSuite.assertEqual(result, {
					subType: "Node"
				})
				m.testSuite.done()
			end sub)
		end function

		@async
		@it("reject AA with subtype")
		function _()
			promise = promises.reject({
				subType: "Node"
			})
			promises.onCatch(promise, sub(result as dynamic)
				m.testSuite.assertEqual(result, {
					subType: "Node"
				})
				m.testSuite.done()
			end sub)
		end function

		@async
		@it("resolved AA with children array")
		function _()
			promise = promises.resolve({
				children: [{ subType: "Node" }]
			})
			promises.onThen(promise, sub(result as dynamic)
				m.testSuite.assertEqual(result, {
					children: [{ subType: "Node" }]
				})
				m.testSuite.done()
			end sub)
		end function

		@async
		@it("reject AA with children array")
		function _()
			promise = promises.reject({
				children: [{ subType: "Node" }]
			})
			promises.onCatch(promise, sub(result as dynamic)
				m.testSuite.assertEqual(result, {
					children: [{ subType: "Node" }]
				})
				m.testSuite.done()
			end sub)
		end function

		@async
		@it("resolved SgNode")
		function _()
			testNode = createNode("Node")
			promise = promises.resolve(testNode)
			promises.onThen(promise, sub(result as dynamic, context as dynamic)
				m.testSuite.assertTrue(context.isSameNode(result))
				m.testSuite.done()
			end sub, testNode)
		end function

		@async
		@it("reject SgNode")
		function _()
			testNode = createNode("Node")
			promise = promises.reject(testNode)
			promises.onCatch(promise, sub(result as dynamic, context as dynamic)
				m.testSuite.assertTrue(context.isSameNode(result))
				m.testSuite.done()
			end sub, testNode)
		end function

		@async(60000)
		@it("unravels deep promise chain without crashing due to stackoverflow")
		function _()
			'this function creates a promise that depends on another promise (until we hit a max)
			doWork = function(context)
				'if we hit the max, resolve the promise and unravel the entire stack
				if context.currentCount > 10000
					return promises.resolve(true)
				end if
				context.currentCount = context.currentCount + 1

				'return a promise that depends on another future promise
				return promises.onThen(promises.resolve(true), function(result, context)
					doWork = context.doWork
					return doWork(context)
				end function, context)
			end function

			promises.chain(promises.resolve(true), {
				currentCount: 0,
				doWork: doWork
			}).then(function(result, context)
				doWork = context.doWork
				return doWork(context)
			end function).then(function(result, context)
				m.testSuite.done()
			end function).catch(function(error, context)
				print "error", error, FormatJson(error.backtrace)
			end function).toPromise()

		end function
	end class
end namespace

function createNode(nodeType = "Node" as string, fields = {} as dynamic) as object
	node = createObject("roSGNode", nodeType)
	node.update(fields, true)
	return node
end function

function sleepPromise(duration = 0.0001 as float) as dynamic
	promise = promises.create()
	promises.internal.delay(sub(promise as dynamic)
		promises.resolve(true, promise)
	end sub, promise, duration)
	return promise
end function

function toPromiseWithDelay(duration = 0.0001 as float, value = true as dynamic, resolve = true as boolean) as dynamic
	differed = promises.create()
	promises.internal.delay(sub(context as dynamic)
		if context.resolve then
			promises.resolve(context.value, context.differed)
		else
			promises.reject(context.value, context.differed)
		end if
	end sub, {differed: differed, value: value, resolve: resolve}, duration)
	return differed
end function
